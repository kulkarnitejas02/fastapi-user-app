from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session
import models, schemas
from fastapi.logger import logger
from fastapi import Query
from dependencies import get_db, get_current_user, get_current_user_id, validate_user_exists
from reportlab.lib.pagesizes import letter  # Standard US letter size (8.5" x 11")
from reportlab.pdfgen import canvas         # PDF drawing canvas
from io import BytesIO                      # In-memory file buffer 
import datetime

router = APIRouter(prefix="/income", tags=["income"])

#Function to create a PDF receipt for maintenance payment
def create_pdf_receipt(maintenance: models.Maintenance, user: models.User):
    """Generate a PDF receipt for maintenance payment"""
    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    width, height = letter

    # Header
    c.setFont("Helvetica-Bold", 16)
    c.drawString(200, height - 50, "APARTMENT MAINTENANCE RECEIPT")
    
    # Receipt details
    c.setFont("Helvetica", 12)
    y_position = height - 100
    
    receipt_data = [
        ("Receipt Date:", datetime.datetime.now().strftime("%Y-%m-%d %H:%M")),
        ("", ""),  # Empty line
        ("Owner Name:", maintenance.owner_name),
        ("Resident Name:", user.name),
        ("Flat Number:", user.flat_number),
        ("Contact ID:", user.contact_id),
        ("", ""),  # Empty line
        ("Payment Date:", str(maintenance.date)),
        ("Payment Month:", f"{maintenance.month} {maintenance.year}"),
        ("Amount Paid:", f"â‚¹{maintenance.amount:.2f}"),
        ("Payment ID:", str(maintenance.id)),
        ("", ""),  # Empty line
        ("Status:", "PAID"),
    ]
    
    for label, value in receipt_data:
        if label and value:
            c.drawString(100, y_position, f"{label}")
            c.drawString(250, y_position, f"{value}")
        y_position -= 25
    
    # Footer
    c.setFont("Helvetica", 10)
    c.drawString(100, 100, "Thank you for your payment!")
    c.drawString(100, 80, "This is an automated receipt generated by Apartment Management System")
    
    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer

@router.post("/", response_model=schemas.MaintenanceOut)
def create_maintenance(
    maintenance: schemas.MaintenanceCreate,
    username: str = Query(...),  # Require username as query param
    db: Session = Depends(get_db)
):
    user = validate_user_exists(username, db)
    
    # Convert to dict to inspect the data
    current_user_id = user.id
    maintenance_data = maintenance.dict()
    maintenance_data['created_by'] = current_user_id  # Set created_by to current user's ID
    print(f"Received maintenance data: {maintenance_data}")
    
        # Convert date string to Python date object
    if isinstance(maintenance_data['date'], str):
        maintenance_data['date'] = datetime.datetime.strptime(maintenance_data['date'], "%Y-%m-%d").date()

    # Validate year field
    if maintenance_data.get('year') is None:
        raise HTTPException(status_code=400, detail="Year field is required")
    
    if maintenance_data.get('year', 0) < 2020 or maintenance_data.get('year', 0) > 2030:
        raise HTTPException(status_code=400, detail="Year must be between 2020 and 2030")
    
    #Validate the flat number exists in users table
    flat_number = maintenance_data.get('paid_by')
    resident_user = db.query(models.User).filter(models.User.flat_number == str(flat_number)).first()
    if not resident_user:
        raise HTTPException(
            status_code=400, 
            detail=f"Flat number {flat_number} not found in residents list. Please enter a valid flat number."
        )
    print(f"Validation successful: Flat {flat_number} belongs to {resident_user.name}")

    # Allow all roles to add maintenance
    new_maintenance = models.Maintenance(**maintenance_data)
    db.add(new_maintenance)
    db.commit()
    db.refresh(new_maintenance)
    return new_maintenance  

@router.get("/", response_model=list[schemas.MaintenanceOut])
def list_maintenance(
    username: str = Query(...),  # Require username as query param
    year: int = Query(None, description="Filter by year (e.g., 2025)"),
    month: str = Query(None, description="Filter by month name (e.g., January)"),
    db: Session = Depends(get_db)
):
    user = get_current_user(username, db)
    # Only secretary/treasurer can view records

    # Build query with optional filters
    query = db.query(models.Maintenance)

    if user.role == "member":
        # Members can only view their own maintenance records
        query = query.filter(models.Maintenance.created_by == user.id)
    elif user.role not in ["secretary", "treasurer"]:
        raise HTTPException(status_code=403, detail="Not authorized to view maintenance records")

    # if user.role not in ["secretary", "treasurer"]:
    #     raise HTTPException(status_code=403, detail="Not authorized to view maintenance records")
    
    # Apply filters if provided
    if year:
        query = query.filter(models.Maintenance.year == year)
    if month:
        query = query.filter(models.Maintenance.month == month)
    
    maintenances = query.all()
    return maintenances


@router.get("/{maintenance_id}/receipt")
def download_receipt(
    maintenance_id: int,
    username: str = Query(...),  # Require username as query param
    db: Session = Depends(get_db)
):
    
    #validate user exist
    user = validate_user_exists(username, db)
    #get maintenance record
    maintenance = db.query(models.Maintenance).filter(models.Maintenance.id == maintenance_id).first()
    if not maintenance:
        raise HTTPException(status_code=404, detail="Maintenance record not found")

    payment_user = db.query(models.User).filter(models.User.flat_number == str(maintenance.paid_by)).first()
    if not payment_user:
        raise HTTPException(status_code=404, detail="User who made the payment not found")
    
    if payment_user.id != user.id and user.role not in ["secretary", "treasurer"]:
        raise HTTPException(status_code=403, detail="Not authorized to download this receipt")
    # GENERATE THE PDF 
    pdf_buffer = create_pdf_receipt(maintenance, payment_user)

    filename = f"maintenance_receipt_{maintenance_id}.pdf"
    
    return StreamingResponse(
        BytesIO(pdf_buffer.getvalue()),
        media_type="application/pdf",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )
